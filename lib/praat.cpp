/*
 * praat.cpp
 *
 * Copyright (C) 2010-2013 Julien Eychenne 
 *
 * This file is part of Dolmen.
 *
 * Dolmen is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License (GPL) as
 * published by the Free Software Foundation, either version 2 of the
 * License, or (at your option) any later version.
 *
 * Dolmen is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Dolmen. If not, see <http://www.gnu.org/licenses/>.
 *
 * Author:  Julien Eychenne
 * Purpose:
 * Created: 01/09/10
 */


#include "praat.h"
#include "utils/Global.h"

namespace
{
    QRegularExpression regex_interval_tier("class\\s+=\\s+\\\"IntervalTier\\\"", QRegularExpression::OptimizeOnFirstUsageOption);
    QRegularExpression regex_point_tier("class\\s+=\\s+\\\"TextTier\\\"", QRegularExpression::OptimizeOnFirstUsageOption);
    QRegularExpression regex_name("name\\s+=\\s+\\\"(.*)\\\"", QRegularExpression::OptimizeOnFirstUsageOption);
    QRegularExpression regex_size("size\\s+=\\s+(\\d*)", QRegularExpression::OptimizeOnFirstUsageOption);

    QRegularExpression regex_interval("intervals\\s+\\[\\d*\\]:", QRegularExpression::OptimizeOnFirstUsageOption);
    QRegularExpression regex_xmin("xmin\\s+=\\s+(\\d+\\.?\\d*)", QRegularExpression::OptimizeOnFirstUsageOption);
    QRegularExpression regex_xmax("xmax\\s+=\\s+(\\d+\\.?\\d*)", QRegularExpression::OptimizeOnFirstUsageOption);
    QRegularExpression regex_text("text\\s+=\\s+\\\"(.*)\\\"", QRegularExpression::OptimizeOnFirstUsageOption);

    QRegularExpression regex_point("points\\s+\\[\\d*\\]:", QRegularExpression::OptimizeOnFirstUsageOption);
    QRegularExpression regex_time("number\\s+=\\s+(\\d+\\.?\\d*)", QRegularExpression::OptimizeOnFirstUsageOption);
    QRegularExpression regex_mark("mark\\s+=\\s+\\\"(.*)\\\"", QRegularExpression::OptimizeOnFirstUsageOption);

    QString seekPattern(QTextStream *stream, QRegularExpression &regex)
    {
        QString line = QString();
        QString result = QString();
        QRegularExpressionMatch match;

        while (! match.hasMatch() && ! stream->atEnd())
        {
            line += stream->readLine();
            match = regex.match(line);
        }

        if (match.lastCapturedIndex() > 0)
            result = match.captured(1);

        return result;
    }
}




// There should be only 1 instance running
PraatInstance::PraatInstance()
{
	// for now, assume praat is already running
	// TODO: check whether praat is running
}

bool PraatInstance::runTemporaryScript(const QString &content)
{
	// build temporary path
#ifdef Q_OS_WIN
	QString scriptPath = QDir::tempPath();
	if (! scriptPath.endsWith(QDir::separator()))
		scriptPath += QDir::separator();
	scriptPath += "temp.praat";
#else
	QString scriptPath("/tmp/temp.praat");
#endif

	// write temporary file
	QFile script(scriptPath);

	if (!script.open(QIODevice::WriteOnly))
		return false;

	QTextStream buffer(&script);
	buffer << content;
	script.close();


	QString args = QString("execute %1").arg(scriptPath);
        QString result = sendpraat(NULL, "praat", 0, args.toStdString().c_str());
	Q_UNUSED(result);

//	// run the script
//	QStringList args;
//	args << "praat" << QString("execute %1").arg(scriptPath);

//	process = new QProcess;
//	connect(process, SIGNAL(finished(int)), this, SLOT(checkProcessExitStatus(int)));
//	process->start(Global::SendpraatPath, args);

	return true;
}

void PraatInstance::checkProcessExitStatus(int exitCode)
{
	if (exitCode == 1)
		emit praat_error(tr("Could not communicate with Praat (is it running?)."));

	disconnect(process, SIGNAL(finished(int)), this, SLOT(checkProcessExitStatus(int)));
	//FIXME: deleting the process crashes on Windows
	//delete process;
}

void PraatInstance::openInterval(int tier, double xmin, const QString &textgrid, const QString &sound)
{
    QString script, min;
    xmin += 0.0001; // make sure we're within the interval

    min.sprintf("%.6f", xmin);

	if (sound.isEmpty())
	{
		script = QString(
				"! Automatically generated by the Dolmen\n"
				"uTier = %1\n"
				"Read from file... %2\n"
				"textgrid$ = selected$(\"TextGrid\", -1)\n"
				"interval = Get interval at time... uTier %3\n"
				"begin = Get starting point... uTier interval\n"
                "begin = begin + 0.0001\n"
				"end = Get end point... uTier interval\n\n"
				"select TextGrid 'textgrid$'\n"
				"Edit\n"
				"editor TextGrid 'textgrid$'\n"
				"	for z from 1 to uTier-1\n"
				"		Select next tier\n"
				"	endfor\n\n"
				"	Zoom... 'begin' 'end'\n"
				"	Move cursor to... 'begin'\n"
				"	Move cursor to begin of selection\n"
				"endeditor\n\n"
                ).arg(tier).arg(textgrid).arg(min);
	}
	else
	{
		script = QString(
				"! Automatically generated by the Dolmen\n"
				"uTier = %1\n"
				"Open long sound file... %2\n"
				"sound$ = selected$(\"LongSound\", -1)\n"
				"Read from file... %3\n"
				"textgrid$ = selected$(\"TextGrid\", -1)\n"
				"interval = Get interval at time... uTier %4\n"
				"begin = Get starting point... uTier interval\n"
                "begin = begin + 0.0001\n"
				"end = Get end point... uTier interval\n\n"
				"select LongSound 'sound$'\n"
				"plus TextGrid 'textgrid$'\n"
				"Edit\n"
				"editor TextGrid 'textgrid$'\n"
				"	for z from 1 to uTier-1\n"
				"		Select next tier\n"
				"	endfor\n\n"
				"	Zoom... 'begin' 'end'\n"
				"	Move cursor to... 'begin'\n"
				"	Move cursor to begin of selection\n"
				"endeditor\n\n"
				).arg(tier).arg(sound).arg(textgrid).arg(xmin);
	}

	runTemporaryScript(script);
}

void PraatInstance::openTextGrid(const QString &textgrid, const QString &sound)
{
	QString script;

	if (sound.isEmpty())
	{
		script = QString(
				"! Automatically generated by the Dolmen\n"
				"Read from file... %1\n"
				"Edit\n"
				).arg(textgrid);
	}
	else
	{
		script = QString(
				"! Automatically generated by the Dolmen\n"
				"Open long sound file... %1\n"
				"sound$ = selected$(\"LongSound\", -1)\n"
				"Read from file... %2\n"
				"textgrid$ = selected$(\"TextGrid\", -1)\n"
				"select LongSound 'sound$'\n"
				"plus TextGrid 'textgrid$'\n"
				"Edit\n"
				).arg(sound).arg(textgrid);
	}

	runTemporaryScript(script);
}

void PraatInstance::openSound(const QString &sound)
{
	QString script = QString(
			"! Automatically generated by the Dolmen\n"
			"Read from file... %1\n"
			"Edit\n"
			).arg(sound);

	runTemporaryScript(script);
}

void PraatInstance::playPart(const QString &sound, double start, double end)
{
	if (sound.isEmpty()) return;

	QString script = QString("Open long sound file... %1\nPlay part... %2 %3")
					 .arg(sound).arg(start).arg(end);

	runTemporaryScript(script);
}


namespace praat
{
	bool readTierHeader(QTextStream *stream, QString *line, QString *name)
	{
        if (regex_interval_tier.match(*line).hasMatch() || regex_point_tier.match(*line).hasMatch())
		{
			*name = seekPattern(stream, regex_name);
			seekPattern(stream, regex_xmin);
			seekPattern(stream, regex_xmax);
			seekPattern(stream, regex_size);

			return true;
		}
		else
			return false;
	}

	bool readInterval(QTextStream *stream, QString *line, double *xmin, double *xmax, QString *text)
	{
		QString result;

        if (regex_interval.match(*line).hasMatch())
		{
			result = seekPattern(stream, regex_xmin);
			*xmin = result.toDouble();

			result = seekPattern(stream, regex_xmax);
			*xmax = result.toDouble();

			*text = seekPattern(stream, regex_text);
			text->replace("\"\"", "\"");

			return true;
		}
		else
			return false;
	}

	bool readPoint(QTextStream *stream, QString *line, double *time, QString *mark)
	{
		QString result;

        if (regex_point.match(*line).hasMatch())
		{
			result = seekPattern(stream, regex_time);
			*time = result.toDouble();

			*mark = seekPattern(stream, regex_mark);
			mark->replace("\"\"", "\"");

			return true;
		}
		else
            return false;
    }


}


